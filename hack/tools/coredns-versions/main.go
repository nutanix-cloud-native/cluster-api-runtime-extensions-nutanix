// Copyright 2024 Nutanix. All rights reserved.
// SPDX-License-Identifier: Apache-2.0

package main

import (
	"bytes"
	"encoding/json"
	"errors"
	"flag"
	"fmt"
	"go/format"
	"io"
	"net/http"
	"os"
	"path"
	"regexp"
	"sort"
	"strings"
	"text/template"

	"github.com/blang/semver/v4"
)

var (
	// Command-line flags
	outputFile           = flag.String("output", "api/versions/coredns.go", "Output file path")
	minKubernetesVersion = flag.String("min-kubernetes-version", "v1.22.0", "Minimum Kubernetes version to include (semver format)")
)

const (
	constantsURLTemplate = "https://raw.githubusercontent.com/kubernetes/kubernetes/v%s/cmd/kubeadm/app/constants/constants.go"
	tagsAPIURL           = "https://api.github.com/repos/kubernetes/kubernetes/tags?per_page=100&page=%d"
)

var goTemplate = `// Copyright 2024 Nutanix. All rights reserved.
// SPDX-License-Identifier: Apache-2.0

// Code generated by script; DO NOT EDIT. Run 'make coredns.sync' instead

package versions

import (
	"fmt"
	"maps"

	"github.com/blang/semver/v4"
)

// Kubernetes versions
const (
{{- range .KubernetesConstants }}
	{{ .Name }} = "{{ .Version }}"
{{- end }}
)

// CoreDNS versions
const (
{{- range .CoreDNSConstants }}
	{{ .Name }} = "{{ .Version }}"
{{- end }}
)

// kubernetesToCoreDNSVersion maps Kubernetes versions to CoreDNS versions.
// This map is unexported to prevent external modification.
var kubernetesToCoreDNSVersion = map[string]string{
{{- range .VersionMap }}
	{{ .KubernetesConst }}: {{ .CoreDNSConst }},
{{- end }}
}

// GetCoreDNSVersion returns the CoreDNS version for a given Kubernetes version.
// It accepts versions with or without the "v" prefix and handles full semver versions.
// The function maps based on the major and minor versions (e.g., "v1.27").
// If the Kubernetes version is not found, it returns an empty string and false.
func GetCoreDNSVersion(kubernetesVersion string) (string, bool) {
	// Parse the version using semver
	v, err := semver.ParseTolerant(kubernetesVersion)
	if err != nil {
		return "", false
	}

	// Construct "vMAJOR.MINOR" format
	majorMinor := fmt.Sprintf("v%d.%d", v.Major, v.Minor)

	// Lookup the CoreDNS version using the major and minor version
	version, found := kubernetesToCoreDNSVersion[majorMinor]
	return version, found
}

// GetKubernetesToCoreDNSVersionMap returns a copy of the Kubernetes to CoreDNS version mapping.
// The map keys are Kubernetes versions in "vMAJOR.MINOR" format.
func GetKubernetesToCoreDNSVersionMap() map[string]string {
	return maps.Clone(kubernetesToCoreDNSVersion)
}
`

func main() {
	flag.Parse()

	// Ensure minKubernetesVersion is in semver format
	if !strings.HasPrefix(*minKubernetesVersion, "v") {
		*minKubernetesVersion = "v" + *minKubernetesVersion
	}

	// Parse the minimum Kubernetes version
	minSemverVersion, err := semver.ParseTolerant(*minKubernetesVersion)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Invalid min-kubernetes-version: %v\n", err)
		os.Exit(1)
	}

	versions, err := fetchKubernetesVersions(minSemverVersion)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error fetching Kubernetes versions: %v\n", err)
		os.Exit(1)
	}

	versionMap, err := fetchCoreDNSVersions(versions)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error fetching CoreDNS versions: %v\n", err)
		os.Exit(1)
	}

	if err := generateGoFile(versionMap, *outputFile); err != nil {
		fmt.Fprintf(os.Stderr, "Error generating Go file: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Successfully generated %s\n", *outputFile)
}

// Fetch Kubernetes versions from GitHub branches
func fetchKubernetesVersions(minVersion semver.Version) ([]semver.Version, error) {
	minorVersionToPatchVersion := make(map[string]semver.Version)
	page := 1

	for {
		url := fmt.Sprintf(tagsAPIURL, page)
		tagNames, err := fetchTagNames(url)
		if err != nil {
			return nil, err
		}

		if len(tagNames) == 0 {
			break
		}

		for _, tag := range tagNames {
			if strings.HasPrefix(tag, "v") {
				v, err := semver.ParseTolerant(tag)
				if err != nil {
					continue // Skip invalid version
				}

				if v.Pre != nil {
					continue // Skip pre-release versions
				}

				if v.LT(minVersion) {
					continue // Skip versions below the minimum
				}

				// Store the highest patch version for each minor version
				minorVersion := fmt.Sprintf("v%d.%d", v.Major, v.Minor)
				if existingPatchVersionForMinor, exists := minorVersionToPatchVersion[minorVersion]; !exists || v.GT(existingPatchVersionForMinor) {
					minorVersionToPatchVersion[minorVersion] = v
				}
			}
		}

		page++
	}

	if len(minorVersionToPatchVersion) == 0 {
		return nil, errors.New("no Kubernetes versions found")
	}

	versions := make(semver.Versions, 0, len(minorVersionToPatchVersion))
	for _, v := range minorVersionToPatchVersion {
		versions = append(versions, v)
	}

	sort.Sort(versions)

	return versions, nil
}

// Fetch branch names from GitHub API
func fetchTagNames(url string) ([]string, error) {
	resp, err := http.Get(url)
	if err != nil {
		return nil, fmt.Errorf("HTTP GET error: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("non-200 HTTP status: %d", resp.StatusCode)
	}

	var tags []struct {
		Name string `json:"name"`
	}

	if err := json.NewDecoder(resp.Body).Decode(&tags); err != nil {
		return nil, fmt.Errorf("decoding JSON error: %w", err)
	}

	tagNames := make([]string, 0, len(tags))
	for _, tag := range tags {
		tagNames = append(tagNames, tag.Name)
	}

	return tagNames, nil
}

func fetchCoreDNSVersions(versions []semver.Version) (map[string]string, error) {
	versionMap := make(map[string]string)
	re := regexp.MustCompile(`CoreDNSVersion\s*=\s*"([^"]+)"`)

	for _, k8sVersion := range versions {
		url := fmt.Sprintf(constantsURLTemplate, k8sVersion)
		coreDNSVersionStr, err := extractCoreDNSVersion(url, re)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Warning: Failed for Kubernetes %s: %v\n", k8sVersion, err)
			continue
		}

		// Parse and normalize CoreDNS version
		v, err := semver.ParseTolerant(coreDNSVersionStr)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Warning: Invalid CoreDNS version '%s' for Kubernetes %s\n", coreDNSVersionStr, k8sVersion)
			continue
		}

		coreDNSVersion := "v" + v.String()

		k8sMajorMinor := fmt.Sprintf("v%d.%d", k8sVersion.Major, k8sVersion.Minor)

		versionMap[k8sMajorMinor] = coreDNSVersion
	}

	if len(versionMap) == 0 {
		return nil, errors.New("no CoreDNS versions found")
	}

	return versionMap, nil
}

func extractCoreDNSVersion(url string, re *regexp.Regexp) (string, error) {
	resp, err := http.Get(url)
	if err != nil {
		return "", fmt.Errorf("HTTP GET error: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return "", fmt.Errorf("non-200 HTTP status: %d", resp.StatusCode)
	}

	bodyBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", fmt.Errorf("reading body error: %w", err)
	}

	matches := re.FindStringSubmatch(string(bodyBytes))
	if len(matches) != 2 {
		return "", errors.New("CoreDNSVersion not found")
	}

	coreDNSVersion := matches[1]
	return coreDNSVersion, nil
}

func generateGoFile(versionMap map[string]string, outputPath string) error {
	data := prepareTemplateData(versionMap)

	tmpl, err := template.New("versionMapping").Parse(goTemplate)
	if err != nil {
		return fmt.Errorf("parsing template error: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return fmt.Errorf("executing template error: %w", err)
	}

	formattedSrc, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("formatting source code error: %w", err)
	}

	if err := os.MkdirAll(path.Dir(outputPath), os.ModePerm); err != nil {
		return fmt.Errorf("creating directories error: %w", err)
	}

	if err := os.WriteFile(outputPath, formattedSrc, 0o644); err != nil {
		return fmt.Errorf("writing file error: %w", err)
	}

	return nil
}

func prepareTemplateData(versionMap map[string]string) map[string]interface{} {
	type Const struct {
		Name    string
		Version string
	}
	var k8sConstants []Const
	var coreDNSConstants []Const

	type versionMapEntry struct {
		KubernetesVersion string
		KubernetesConst   string
		CoreDNSConst      string
	}
	var versionMapList []versionMapEntry

	// Maps for deduplication
	k8sConstMap := make(map[string]string)
	coreDNSConstMap := make(map[string]string)

	// Collect unique CoreDNS versions
	uniqueCoreDNSVersions := make(map[string]struct{})
	for _, coreDNSVersion := range versionMap {
		uniqueCoreDNSVersions[coreDNSVersion] = struct{}{}
	}

	// Generate constants for CoreDNS versions
	for coreDNSVersion := range uniqueCoreDNSVersions {
		constName := versionToConst("CoreDNS", coreDNSVersion)
		coreDNSConstMap[coreDNSVersion] = constName
		coreDNSConstants = append(coreDNSConstants, Const{Name: constName, Version: coreDNSVersion})
	}

	// Generate constants and mapping for Kubernetes versions
	for k8sVersion := range versionMap {
		if _, exists := k8sConstMap[k8sVersion]; !exists {
			constName := versionToConst("Kubernetes", k8sVersion)
			k8sConstMap[k8sVersion] = constName
			k8sConstants = append(k8sConstants, Const{Name: constName, Version: k8sVersion})
		}
	}

	// Map Kubernetes constants to CoreDNS constants
	for k8sVersion, coreDNSVersion := range versionMap {
		versionMapList = append(versionMapList, versionMapEntry{
			KubernetesVersion: k8sVersion,
			KubernetesConst:   k8sConstMap[k8sVersion],
			CoreDNSConst:      coreDNSConstMap[coreDNSVersion],
		})
	}

	// Sort constants
	sort.Slice(k8sConstants, func(i, j int) bool {
		v1, err1 := semver.ParseTolerant(k8sConstants[i].Version)
		v2, err2 := semver.ParseTolerant(k8sConstants[j].Version)
		if err1 != nil || err2 != nil {
			return k8sConstants[i].Version < k8sConstants[j].Version
		}
		return v1.LT(v2)
	})

	sort.Slice(coreDNSConstants, func(i, j int) bool {
		v1, err1 := semver.ParseTolerant(coreDNSConstants[i].Version)
		v2, err2 := semver.ParseTolerant(coreDNSConstants[j].Version)
		if err1 != nil || err2 != nil {
			return coreDNSConstants[i].Version < coreDNSConstants[j].Version
		}
		return v1.LT(v2)
	})

	// Sort version map
	sort.Slice(versionMapList, func(i, j int) bool {
		v1, err1 := semver.ParseTolerant(versionMapList[i].KubernetesVersion)
		v2, err2 := semver.ParseTolerant(versionMapList[j].KubernetesVersion)
		if err1 != nil || err2 != nil {
			return versionMapList[i].KubernetesVersion < versionMapList[j].KubernetesVersion
		}
		return v1.LT(v2)
	})

	data := map[string]interface{}{
		"KubernetesConstants": k8sConstants,
		"CoreDNSConstants":    coreDNSConstants,
		"VersionMap":          versionMapList,
	}

	return data
}

func versionToConst(prefix, version string) string {
	// Remove 'v' prefix if present
	versionNoV := strings.TrimPrefix(version, "v")
	// Replace dots with underscores
	versionNoV = strings.ReplaceAll(versionNoV, ".", "_")
	// Prepend the prefix and 'V'
	return prefix + "_V" + versionNoV
}
