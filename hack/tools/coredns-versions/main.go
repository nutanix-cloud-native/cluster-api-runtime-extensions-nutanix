// Copyright 2024 Nutanix. All rights reserved.
// SPDX-License-Identifier: Apache-2.0

package main

import (
	"bytes"
	"context"
	"errors"
	"flag"
	"fmt"
	"go/format"
	"os"
	"os/signal"
	"path"
	"regexp"
	"sort"
	"strings"
	"text/template"

	"github.com/blang/semver/v4"
	"github.com/google/go-github/v72/github"
)

var (
	// Command-line flags.
	outputFile           = flag.String("output", "api/versions/coredns.go", "Output file path")
	minKubernetesVersion = flag.String(
		"min-kubernetes-version",
		"v1.22.0",
		"Minimum Kubernetes version to include (semver format)",
	)
)

const (
	kubeadmConstantsFilePathInRepo = "cmd/kubeadm/app/constants/constants.go"
)

var goTemplate = `// Copyright 2024 Nutanix. All rights reserved.
// SPDX-License-Identifier: Apache-2.0

// Code generated by script; DO NOT EDIT. Run 'make coredns.sync' instead

package versions

import (
	"fmt"
	"maps"

	"github.com/blang/semver/v4"
)

// Kubernetes versions.
const (
{{- range .KubernetesConstants }}
	{{ .Name }} = "{{ .Version }}"
{{- end }}
)

// CoreDNS versions.
const (
{{- range .CoreDNSConstants }}
	{{ .Name }} = "{{ .Version }}"
{{- end }}
)

// kubernetesToCoreDNSVersion maps Kubernetes versions to CoreDNS versions.
// This map is unexported to prevent external modification.
var kubernetesToCoreDNSVersion = map[string]string{
{{- range .VersionMap }}
	{{ .KubernetesConst }}: {{ .CoreDNSConst }},
{{- end }}
}

// GetCoreDNSVersion returns the CoreDNS version for a given Kubernetes version.
// It accepts versions with or without the "v" prefix and handles full semver versions.
// The function maps based on the major and minor versions (e.g., "v1.27").
// If the Kubernetes version is not found, it returns an empty string and false.
func GetCoreDNSVersion(kubernetesVersion string) (string, bool) {
	// Parse the version using semver
	v, err := semver.ParseTolerant(kubernetesVersion)
	if err != nil {
		return "", false
	}

	// Construct "vMAJOR.MINOR" format
	majorMinor := fmt.Sprintf("v%d.%d", v.Major, v.Minor)

	// Lookup the CoreDNS version using the major and minor version
	version, found := kubernetesToCoreDNSVersion[majorMinor]
	return version, found
}

// GetKubernetesToCoreDNSVersionMap returns a copy of the Kubernetes to CoreDNS version mapping.
// The map keys are Kubernetes versions in "vMAJOR.MINOR" format.
func GetKubernetesToCoreDNSVersionMap() map[string]string {
	return maps.Clone(kubernetesToCoreDNSVersion)
}
`

func main() {
	flag.Parse()

	// Ensure minKubernetesVersion is in semver format
	if !strings.HasPrefix(*minKubernetesVersion, "v") {
		*minKubernetesVersion = "v" + *minKubernetesVersion
	}

	// Parse the minimum Kubernetes version
	minSemverVersion, err := semver.ParseTolerant(*minKubernetesVersion)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Invalid min-kubernetes-version: %v\n", err)
		os.Exit(1)
	}

	ctx, cancelFunc := signal.NotifyContext(context.Background(), os.Interrupt)
	defer cancelFunc()

	ghClient := github.NewClient(nil)
	if ghToken := os.Getenv("GH_TOKEN"); ghToken != "" {
		ghClient = ghClient.WithAuthToken(ghToken)
	}

	versions, err := fetchKubernetesVersions(ctx, minSemverVersion, ghClient)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error fetching Kubernetes versions: %v\n", err)
		os.Exit(1) //nolint:gocritic // Will still be clean exit.
	}

	versionMap, err := fetchCoreDNSVersions(ctx, versions, ghClient)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error fetching CoreDNS versions: %v\n", err)
		os.Exit(1)
	}

	if err := generateGoFile(versionMap, *outputFile); err != nil {
		fmt.Fprintf(os.Stderr, "Error generating Go file: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Successfully generated %s\n", *outputFile)
}

// Fetch Kubernetes versions from GitHub branches.
func fetchKubernetesVersions(
	ctx context.Context,
	minVersion semver.Version,
	ghClient *github.Client,
) ([]semver.Version, error) {
	listOptions := &github.ListOptions{
		PerPage: 100,
	}

	minorVersionToPatchVersion := make(map[string]semver.Version)
	for {
		tags, resp, err := ghClient.Repositories.ListTags(ctx, "kubernetes", "kubernetes", listOptions)
		if err != nil {
			return nil, fmt.Errorf("failed to list Kubernetes versions: %w", err)
		}

		for _, tag := range tags {
			if !strings.HasPrefix(tag.GetName(), "v") {
				continue // Skip tags without 'v' prefix
			}

			v, err := semver.ParseTolerant(tag.GetName())
			if err != nil {
				continue // Skip invalid versions
			}
			if v.Pre != nil {
				continue // Skip pre-release versions
			}
			if v.LT(minVersion) {
				continue // Skip versions below the minimum
			}
			// Store the highest patch version for each minor version
			minorVersion := fmt.Sprintf("v%d.%d", v.Major, v.Minor)
			if existingPatchVersionForMinor, exists := minorVersionToPatchVersion[minorVersion]; !exists ||
				v.GT(existingPatchVersionForMinor) {
				minorVersionToPatchVersion[minorVersion] = v
			}
		}

		if resp.NextPage == 0 {
			break
		}

		listOptions.Page = resp.NextPage
	}

	if len(minorVersionToPatchVersion) == 0 {
		return nil, errors.New("no Kubernetes versions found")
	}

	versions := make(semver.Versions, 0, len(minorVersionToPatchVersion))
	for _, v := range minorVersionToPatchVersion {
		versions = append(versions, v)
	}

	sort.Sort(versions)

	return versions, nil
}

func fetchCoreDNSVersions(
	ctx context.Context, versions []semver.Version, ghClient *github.Client,
) (map[string]string, error) {
	versionMap := make(map[string]string, len(versions))

	re := regexp.MustCompile(`CoreDNSVersion\s*=\s*"([^"]+)"`)

	for _, k8sVersion := range versions {
		fileContent, _, _, err := ghClient.Repositories.GetContents(
			ctx,
			"kubernetes",
			"kubernetes",
			kubeadmConstantsFilePathInRepo,
			&github.RepositoryContentGetOptions{
				Ref: "v" + k8sVersion.String(),
			},
		)
		if err != nil {
			return nil, fmt.Errorf(
				"failed to get Kubeadm constants file contents for Kubernetes version v%s: %w",
				k8sVersion,
				err,
			)
		}

		decodedContent, err := fileContent.GetContent()
		if err != nil {
			return nil, fmt.Errorf(
				"failed to decode Kubeadm constants file contents for Kubernetes version v%s: %w",
				k8sVersion,
				err,
			)
		}

		matches := re.FindStringSubmatch(decodedContent)
		if len(matches) != 2 {
			return nil, errors.New(
				"CoreDNS version not found in Kubeadm constants file for Kubernetes version " + k8sVersion.String(),
			)
		}

		coreDNSVersionStr := matches[1]

		// Parse and normalize CoreDNS version
		v, err := semver.ParseTolerant(coreDNSVersionStr)
		if err != nil {
			return nil, fmt.Errorf(
				"invalid CoreDNS version '%s' for Kubernetes %s: %w",
				coreDNSVersionStr,
				k8sVersion,
				err,
			)
		}

		coreDNSVersion := "v" + v.String()

		k8sMajorMinor := fmt.Sprintf("v%d.%d", k8sVersion.Major, k8sVersion.Minor)

		versionMap[k8sMajorMinor] = coreDNSVersion
	}

	if len(versionMap) == 0 {
		return nil, errors.New("no CoreDNS versions found")
	}

	return versionMap, nil
}

func generateGoFile(versionMap map[string]string, outputPath string) error {
	data := prepareTemplateData(versionMap)

	tmpl, err := template.New("versionMapping").Parse(goTemplate)
	if err != nil {
		return fmt.Errorf("parsing template error: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return fmt.Errorf("executing template error: %w", err)
	}

	formattedSrc, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("formatting source code error: %w", err)
	}

	if err := os.MkdirAll(path.Dir(outputPath), os.ModePerm); err != nil {
		return fmt.Errorf("creating directories error: %w", err)
	}

	if err := os.WriteFile(outputPath, formattedSrc, 0o644); err != nil { //nolint:gosec // Should be world readable.
		return fmt.Errorf("writing file error: %w", err)
	}

	return nil
}

func prepareTemplateData(versionMap map[string]string) map[string]interface{} {
	type Const struct {
		Name    string
		Version string
	}

	type versionMapEntry struct {
		KubernetesVersion string
		KubernetesConst   string
		CoreDNSConst      string
	}

	// Maps for deduplication
	k8sConstMap := make(map[string]string)
	coreDNSConstMap := make(map[string]string)

	// Collect unique CoreDNS versions
	uniqueCoreDNSVersions := make(map[string]struct{})
	for _, coreDNSVersion := range versionMap {
		uniqueCoreDNSVersions[coreDNSVersion] = struct{}{}
	}

	// Generate constants for CoreDNS versions
	coreDNSConstants := make([]Const, 0, len(uniqueCoreDNSVersions))
	for coreDNSVersion := range uniqueCoreDNSVersions {
		constName := versionToConst("CoreDNS", coreDNSVersion)
		coreDNSConstMap[coreDNSVersion] = constName
		coreDNSConstants = append(coreDNSConstants, Const{Name: constName, Version: coreDNSVersion})
	}

	// Generate constants and mapping for Kubernetes versions
	k8sConstants := make([]Const, 0, len(versionMap))
	for k8sVersion := range versionMap {
		if _, exists := k8sConstMap[k8sVersion]; !exists {
			constName := versionToConst("Kubernetes", k8sVersion)
			k8sConstMap[k8sVersion] = constName
			k8sConstants = append(k8sConstants, Const{Name: constName, Version: k8sVersion})
		}
	}

	// Map Kubernetes constants to CoreDNS constants
	versionMapList := make([]versionMapEntry, 0, len(versionMap))
	for k8sVersion, coreDNSVersion := range versionMap {
		versionMapList = append(versionMapList, versionMapEntry{
			KubernetesVersion: k8sVersion,
			KubernetesConst:   k8sConstMap[k8sVersion],
			CoreDNSConst:      coreDNSConstMap[coreDNSVersion],
		})
	}

	// Sort constants
	sort.Slice(k8sConstants, func(i, j int) bool {
		v1, err1 := semver.ParseTolerant(k8sConstants[i].Version)
		v2, err2 := semver.ParseTolerant(k8sConstants[j].Version)
		if err1 != nil || err2 != nil {
			return k8sConstants[i].Version < k8sConstants[j].Version
		}
		return v1.LT(v2)
	})

	sort.Slice(coreDNSConstants, func(i, j int) bool {
		v1, err1 := semver.ParseTolerant(coreDNSConstants[i].Version)
		v2, err2 := semver.ParseTolerant(coreDNSConstants[j].Version)
		if err1 != nil || err2 != nil {
			return coreDNSConstants[i].Version < coreDNSConstants[j].Version
		}
		return v1.LT(v2)
	})

	// Sort version map
	sort.Slice(versionMapList, func(i, j int) bool {
		v1, err1 := semver.ParseTolerant(versionMapList[i].KubernetesVersion)
		v2, err2 := semver.ParseTolerant(versionMapList[j].KubernetesVersion)
		if err1 != nil || err2 != nil {
			return versionMapList[i].KubernetesVersion < versionMapList[j].KubernetesVersion
		}
		return v1.LT(v2)
	})

	data := map[string]interface{}{
		"KubernetesConstants": k8sConstants,
		"CoreDNSConstants":    coreDNSConstants,
		"VersionMap":          versionMapList,
	}

	return data
}

func versionToConst(prefix, version string) string {
	// Remove 'v' prefix if present
	versionNoV := strings.TrimPrefix(version, "v")
	// Replace dots with underscores
	versionNoV = strings.ReplaceAll(versionNoV, ".", "_")
	// Prepend the prefix and 'V'
	return prefix + "_V" + versionNoV
}
