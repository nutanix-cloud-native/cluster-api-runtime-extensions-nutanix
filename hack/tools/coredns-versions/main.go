// Copyright 2024 Nutanix. All rights reserved.
// SPDX-License-Identifier: Apache-2.0

package main

import (
	"bytes"
	"encoding/json"
	"errors"
	"flag"
	"fmt"
	"go/format"
	"io"
	"net/http"
	"os"
	"path"
	"regexp"
	"sort"
	"strings"
	"text/template"

	"golang.org/x/mod/semver"
)

var (
	// Command-line flags
	outputFile           = flag.String("output", "api/versions/coredns.go", "Output file path")
	minKubernetesVersion = flag.String("min-kubernetes-version", "v1.22", "Minimum Kubernetes version to include (semver format)")
)

const (
	constantsURLTemplate = "https://raw.githubusercontent.com/kubernetes/kubernetes/%s/cmd/kubeadm/app/constants/constants.go"
	branchesAPIURL       = "https://api.github.com/repos/kubernetes/kubernetes/branches?per_page=100&page=%d"
)

var goTemplate = `
// Copyright 2024 Nutanix. All rights reserved.
// SPDX-License-Identifier: Apache-2.0
// Code generated by script; DO NOT EDIT. Run 'make coredns.sync' instead

package versions

// Kubernetes versions
const (
{{- range .KubernetesConstants }}
	{{ .Name }} = "{{ .Version }}"
{{- end }}
)

// CoreDNS versions
const (
{{- range .CoreDNSConstants }}
	{{ .Name }} = "{{ .Version }}"
{{- end }}
)

// kubernetesToCoreDNSVersion maps Kubernetes versions to CoreDNS versions.
var kubernetesToCoreDNSVersion = map[string]string{
{{- range .VersionMap }}
	{{ .KubernetesConst }}: {{ .CoreDNSConst }},
{{- end }}
}

// GetCoreDNSVersion returns the CoreDNS version for a given Kubernetes version.
// If the Kubernetes version is not found, it returns an empty string and false.
func GetCoreDNSVersion(kubernetesVersion string) (string, bool) {
	version, found := kubernetesToCoreDNSVersion[kubernetesVersion]
	return version, found
}

// GetKubernetesToCoreDNSVersionMap returns a copy of the Kubernetes to CoreDNS version mapping.
func GetKubernetesToCoreDNSVersionMap() map[string]string {
	copyMap := make(map[string]string, len(kubernetesToCoreDNSVersion))
	for k, v := range kubernetesToCoreDNSVersion {
		copyMap[k] = v
	}

	return copyMap
}
`

func main() {
	flag.Parse()

	// Ensure minKubernetesVersion is in semver format (prefixed with 'v')
	if !strings.HasPrefix(*minKubernetesVersion, "v") {
		*minKubernetesVersion = "v" + *minKubernetesVersion
	}

	versions, err := fetchKubernetesVersions(*minKubernetesVersion)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error fetching Kubernetes versions: %v\n", err)
		os.Exit(1)
	}

	versionMap, err := fetchCoreDNSVersions(versions)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error fetching CoreDNS versions: %v\n", err)
		os.Exit(1)
	}

	if err := generateGoFile(versionMap, *outputFile); err != nil {
		fmt.Fprintf(os.Stderr, "Error generating Go file: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Successfully generated %s\n", *outputFile)
}

// Fetch Kubernetes versions from GitHub branches
func fetchKubernetesVersions(minVersion string) ([]string, error) {
	var versions []string
	page := 1
	for {
		url := fmt.Sprintf(branchesAPIURL, page)
		branchNames, err := fetchBranchNames(url)
		if err != nil {
			return nil, err
		}
		if len(branchNames) == 0 {
			break
		}
		for _, branch := range branchNames {
			if strings.HasPrefix(branch, "release-1.") {
				version := strings.TrimPrefix(branch, "release-")
				semverVersion := "v" + version
				if semver.Compare(semverVersion, minVersion) >= 0 {
					versions = append(versions, version)
				}
			}
		}
		page++
	}
	if len(versions) == 0 {
		return nil, errors.New("no Kubernetes versions found")
	}
	// Remove duplicates and sort
	versionSet := make(map[string]struct{})
	for _, v := range versions {
		versionSet[v] = struct{}{}
	}
	versions = nil
	for v := range versionSet {
		versions = append(versions, v)
	}
	sort.Slice(versions, func(i, j int) bool {
		return semver.Compare("v"+versions[i], "v"+versions[j]) < 0
	})
	return versions, nil
}

// Fetch branch names from GitHub API
func fetchBranchNames(url string) ([]string, error) {
	resp, err := http.Get(url)
	if err != nil {
		return nil, fmt.Errorf("HTTP GET error: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("non-200 HTTP status: %d", resp.StatusCode)
	}

	var branches []struct {
		Name string `json:"name"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&branches); err != nil {
		return nil, fmt.Errorf("decoding JSON error: %w", err)
	}

	var branchNames []string
	for _, branch := range branches {
		branchNames = append(branchNames, branch.Name)
	}
	return branchNames, nil
}

func fetchCoreDNSVersions(versions []string) (map[string]string, error) {
	versionMap := make(map[string]string)
	re := regexp.MustCompile(`CoreDNSVersion\s*=\s*"([^"]+)"`)

	for _, k8sVersion := range versions {
		branch := "release-" + k8sVersion
		url := fmt.Sprintf(constantsURLTemplate, branch)
		coreDNSVersion, err := extractCoreDNSVersion(url, re)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Warning: Failed for Kubernetes %s: %v\n", k8sVersion, err)
			continue
		}
		versionMap[k8sVersion] = coreDNSVersion
	}

	if len(versionMap) == 0 {
		return nil, errors.New("no CoreDNS versions found")
	}

	return versionMap, nil
}

func extractCoreDNSVersion(url string, re *regexp.Regexp) (string, error) {
	resp, err := http.Get(url)
	if err != nil {
		return "", fmt.Errorf("HTTP GET error: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return "", fmt.Errorf("non-200 HTTP status: %d", resp.StatusCode)
	}

	bodyBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", fmt.Errorf("reading body error: %w", err)
	}

	matches := re.FindStringSubmatch(string(bodyBytes))
	if len(matches) != 2 {
		return "", errors.New("CoreDNSVersion not found")
	}

	return matches[1], nil
}

func generateGoFile(versionMap map[string]string, outputPath string) error {
	data := prepareTemplateData(versionMap)

	tmpl, err := template.New("versionMapping").Parse(goTemplate)
	if err != nil {
		return fmt.Errorf("parsing template error: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return fmt.Errorf("executing template error: %w", err)
	}

	formattedSrc, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("formatting source code error: %w", err)
	}

	if err := os.MkdirAll(path.Dir(outputPath), os.ModePerm); err != nil {
		return fmt.Errorf("creating directories error: %w", err)
	}

	if err := os.WriteFile(outputPath, formattedSrc, 0644); err != nil {
		return fmt.Errorf("writing file error: %w", err)
	}

	return nil
}

func prepareTemplateData(versionMap map[string]string) map[string]interface{} {
	type Const struct {
		Name    string
		Version string
	}
	var k8sConstants []Const
	var coreDNSConstants []Const
	type versionMapEntry struct {
		KubernetesVersion string
		KubernetesConst   string
		CoreDNSConst      string
	}
	var versionMapList []versionMapEntry

	// Maps for deduplication
	k8sConstMap := make(map[string]string)
	coreDNSConstMap := make(map[string]string)

	// Collect unique CoreDNS versions
	uniqueCoreDNSVersions := make(map[string]struct{})
	for _, coreDNSVersion := range versionMap {
		uniqueCoreDNSVersions[coreDNSVersion] = struct{}{}
	}

	// Generate constants for Kubernetes versions
	for k8sVersion := range versionMap {
		constName := versionToConst("Kubernetes", k8sVersion)
		k8sConstMap[k8sVersion] = constName
	}

	// Generate constants for CoreDNS versions
	for coreDNSVersion := range uniqueCoreDNSVersions {
		constName := versionToConst("CoreDNS", coreDNSVersion)
		coreDNSConstMap[coreDNSVersion] = constName
	}

	// Prepare constants slices
	for k8sVersion, constName := range k8sConstMap {
		k8sConstants = append(k8sConstants, Const{Name: constName, Version: k8sVersion})
	}
	for coreDNSVersion, constName := range coreDNSConstMap {
		coreDNSConstants = append(coreDNSConstants, Const{Name: constName, Version: coreDNSVersion})
	}

	// Sort constants
	sort.Slice(k8sConstants, func(i, j int) bool {
		return semver.Compare("v"+k8sConstants[i].Version, "v"+k8sConstants[j].Version) < 0
	})
	sort.Slice(coreDNSConstants, func(i, j int) bool {
		return semver.Compare(coreDNSConstants[i].Version, coreDNSConstants[j].Version) < 0
	})

	// Map Kubernetes constants to CoreDNS constants
	for k8sVersion, coreDNSVersion := range versionMap {
		versionMapList = append(versionMapList, versionMapEntry{
			KubernetesVersion: k8sVersion,
			KubernetesConst:   k8sConstMap[k8sVersion],
			CoreDNSConst:      coreDNSConstMap[coreDNSVersion],
		})
	}

	// Sort version map
	sort.Slice(versionMapList, func(i, j int) bool {
		return semver.Compare("v"+versionMapList[i].KubernetesVersion, "v"+versionMapList[j].KubernetesVersion) < 0
	})

	data := map[string]interface{}{
		"KubernetesConstants": k8sConstants,
		"CoreDNSConstants":    coreDNSConstants,
		"VersionMap":          versionMapList,
	}

	return data
}

func versionToConst(prefix, version string) string {
	// Remove 'v' prefix if present
	version = strings.TrimPrefix(version, "v")
	// Replace dots with underscores
	version = strings.ReplaceAll(version, ".", "_")
	// Prepend the prefix and 'V'
	return prefix + "_V" + version
}
