// Copyright 2024 Nutanix. All rights reserved.
// SPDX-License-Identifier: Apache-2.0

package main

import (
	"bytes"
	"encoding/json"
	"errors"
	"flag"
	"fmt"
	"go/format"
	"io"
	"net/http"
	"os"
	"path"
	"regexp"
	"sort"
	"strings"
	"text/template"

	"golang.org/x/mod/semver"
)

var (
	// Command-line flags
	outputFile           = flag.String("output", "api/versions/coredns.go", "Output file path")
	minKubernetesVersion = flag.String("min-kubernetes-version", "v1.22.0", "Minimum Kubernetes version to include (semver format)")
)

const (
	constantsURLTemplate = "https://raw.githubusercontent.com/kubernetes/kubernetes/%s/cmd/kubeadm/app/constants/constants.go"
	branchesAPIURL       = "https://api.github.com/repos/kubernetes/kubernetes/branches?per_page=100&page=%d"
)

var goTemplate = `
// Copyright 2024 Nutanix. All rights reserved.
// SPDX-License-Identifier: Apache-2.0

// Code generated by script; DO NOT EDIT. Run 'make coredns.sync' instead

package versions

import (
	"golang.org/x/mod/semver"
)

// Kubernetes versions
const (
{{- range .KubernetesConstants }}
	{{ .Name }} = "{{ .Version }}"
{{- end }}
)

// CoreDNS versions
const (
{{- range .CoreDNSConstants }}
	{{ .Name }} = "{{ .Version }}"
{{- end }}
)

// kubernetesToCoreDNSVersion maps Kubernetes versions to CoreDNS versions.
// This map is unexported to prevent external modification.
var kubernetesToCoreDNSVersion = map[string]string{
{{- range .VersionMap }}
	{{ .KubernetesConst }}: {{ .CoreDNSConst }},
{{- end }}
}

// GetCoreDNSVersion returns the CoreDNS version for a given Kubernetes version.
// It accepts versions with or without the "v" prefix and handles full semver versions.
// The function maps based on the major and minor versions (e.g., "v1.27").
// If the Kubernetes version is not found, it returns an empty string and false.
func GetCoreDNSVersion(kubernetesVersion string) (string, bool) {
	// Normalize the version using semver
	normalizedVersion := semver.Canonical(kubernetesVersion)
	if normalizedVersion == "" {
		// Handle invalid version strings
		return "", false
	}

	// Extract major and minor versions
	majorMinor := semver.MajorMinor(normalizedVersion) // e.g., "v1.27"

	// Lookup the CoreDNS version using the major and minor version
	version, found := kubernetesToCoreDNSVersion[majorMinor]
	return version, found
}

// GetKubernetesToCoreDNSVersionMap returns a copy of the Kubernetes to CoreDNS version mapping.
// The map keys are Kubernetes versions in "vMAJOR.MINOR" format.
func GetKubernetesToCoreDNSVersionMap() map[string]string {
	copyMap := make(map[string]string, len(kubernetesToCoreDNSVersion))
	for k, v := range kubernetesToCoreDNSVersion {
		copyMap[k] = v
	}
	return copyMap
}
`

func main() {
	flag.Parse()

	// Ensure minKubernetesVersion is in semver format (prefixed with 'v')
	if !strings.HasPrefix(*minKubernetesVersion, "v") {
		*minKubernetesVersion = "v" + *minKubernetesVersion
	}
	// Ensure minKubernetesVersion has patch version
	if semver.Prerelease(*minKubernetesVersion) == "" && semver.Build(*minKubernetesVersion) == "" && len(strings.Split(semver.Canonical(*minKubernetesVersion), ".")) == 2 {
		*minKubernetesVersion += ".0"
	}

	versions, err := fetchKubernetesVersions(*minKubernetesVersion)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error fetching Kubernetes versions: %v\n", err)
		os.Exit(1)
	}

	versionMap, err := fetchCoreDNSVersions(versions)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error fetching CoreDNS versions: %v\n", err)
		os.Exit(1)
	}

	if err := generateGoFile(versionMap, *outputFile); err != nil {
		fmt.Fprintf(os.Stderr, "Error generating Go file: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Successfully generated %s\n", *outputFile)
}

// Fetch Kubernetes versions from GitHub branches
func fetchKubernetesVersions(minVersion string) ([]string, error) {
	var versions []string
	page := 1
	for {
		url := fmt.Sprintf(branchesAPIURL, page)
		branchNames, err := fetchBranchNames(url)
		if err != nil {
			return nil, err
		}

		if len(branchNames) == 0 {
			break
		}

		for _, branch := range branchNames {
			if strings.HasPrefix(branch, "release-1.") {
				version := strings.TrimPrefix(branch, "release-")
				semverVersion := "v" + version + ".0"
				if semver.Compare(semverVersion, minVersion) >= 0 {
					versions = append(versions, version)
				}
			}
		}

		page++
	}

	if len(versions) == 0 {
		return nil, errors.New("no Kubernetes versions found")
	}
	// Remove duplicates and sort
	versionSet := make(map[string]struct{})
	for _, v := range versions {
		versionSet[v] = struct{}{}
	}

	versions = nil
	for v := range versionSet {
		versions = append(versions, v)
	}

	sort.Slice(versions, func(i, j int) bool {
		return semver.Compare("v"+versions[i]+".0", "v"+versions[j]+".0") < 0
	})

	return versions, nil
}

// Fetch branch names from GitHub API
func fetchBranchNames(url string) ([]string, error) {
	resp, err := http.Get(url)
	if err != nil {
		return nil, fmt.Errorf("HTTP GET error: %w", err)
	}

	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("non-200 HTTP status: %d", resp.StatusCode)
	}

	var branches []struct {
		Name string `json:"name"`
	}

	if err := json.NewDecoder(resp.Body).Decode(&branches); err != nil {
		return nil, fmt.Errorf("decoding JSON error: %w", err)
	}

	var branchNames []string
	for _, branch := range branches {
		branchNames = append(branchNames, branch.Name)
	}

	return branchNames, nil
}

func fetchCoreDNSVersions(versions []string) (map[string]string, error) {
	versionMap := make(map[string]string)
	re := regexp.MustCompile(`CoreDNSVersion\s*=\s*"([^"]+)"`)
	for _, k8sVersion := range versions {
		branch := "release-" + k8sVersion
		url := fmt.Sprintf(constantsURLTemplate, branch)
		coreDNSVersion, err := extractCoreDNSVersion(url, re)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Warning: Failed for Kubernetes %s: %v\n", k8sVersion, err)
			continue
		}

		// Normalize CoreDNS version using semver
		coreDNSVersion = semver.Canonical(coreDNSVersion)
		if coreDNSVersion == "" {
			fmt.Fprintf(os.Stderr, "Warning: Invalid CoreDNS version '%s' for Kubernetes %s\n", coreDNSVersion, k8sVersion)
			continue
		}
		// Prefix Kubernetes version with "v" and add ".0" for patch version
		fullVersion := "v" + k8sVersion + ".0"
		majorMinor := semver.MajorMinor(fullVersion)
		versionMap[majorMinor] = coreDNSVersion
	}

	if len(versionMap) == 0 {
		return nil, errors.New("no CoreDNS versions found")
	}

	return versionMap, nil
}

func extractCoreDNSVersion(url string, re *regexp.Regexp) (string, error) {
	resp, err := http.Get(url)
	if err != nil {
		return "", fmt.Errorf("HTTP GET error: %w", err)
	}

	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return "", fmt.Errorf("non-200 HTTP status: %d", resp.StatusCode)
	}

	bodyBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", fmt.Errorf("reading body error: %w", err)
	}

	matches := re.FindStringSubmatch(string(bodyBytes))
	if len(matches) != 2 {
		return "", errors.New("CoreDNSVersion not found")
	}

	// Ensure CoreDNS version includes "v" prefix
	coreDNSVersion := matches[1]
	if !strings.HasPrefix(coreDNSVersion, "v") {
		coreDNSVersion = "v" + coreDNSVersion
	}

	return coreDNSVersion, nil
}

func generateGoFile(versionMap map[string]string, outputPath string) error {
	data := prepareTemplateData(versionMap)

	tmpl, err := template.New("versionMapping").Parse(goTemplate)
	if err != nil {
		return fmt.Errorf("parsing template error: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return fmt.Errorf("executing template error: %w", err)
	}

	formattedSrc, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("formatting source code error: %w", err)
	}

	if err := os.MkdirAll(path.Dir(outputPath), os.ModePerm); err != nil {
		return fmt.Errorf("creating directories error: %w", err)
	}

	if err := os.WriteFile(outputPath, formattedSrc, 0644); err != nil {
		return fmt.Errorf("writing file error: %w", err)
	}

	return nil
}

func prepareTemplateData(versionMap map[string]string) map[string]interface{} {
	type Const struct {
		Name    string
		Version string
	}

	type versionMapEntry struct {
		KubernetesVersion string
		KubernetesConst   string
		CoreDNSConst      string
	}

	var versionMapList []versionMapEntry

	// Maps for deduplication
	k8sConstMap := make(map[string]string)
	coreDNSConstMap := make(map[string]string)

	// Collect unique CoreDNS versions
	uniqueCoreDNSVersions := make(map[string]struct{})
	for _, coreDNSVersion := range versionMap {
		uniqueCoreDNSVersions[coreDNSVersion] = struct{}{}
	}

	var k8sConstants []Const
	var coreDNSConstants []Const
	// Generate constants for CoreDNS versions
	for coreDNSVersion := range uniqueCoreDNSVersions {
		constName := versionToConst("CoreDNS", coreDNSVersion)
		coreDNSConstMap[coreDNSVersion] = constName
		coreDNSConstants = append(coreDNSConstants, Const{Name: constName, Version: coreDNSVersion})
	}

	// Generate constants and mapping for Kubernetes versions
	for k8sVersion := range versionMap {
		// Constants and mapping use major.minor versions
		majorMinor := semver.MajorMinor(k8sVersion)
		if _, exists := k8sConstMap[majorMinor]; !exists {
			constName := versionToConst("Kubernetes", majorMinor)
			k8sConstMap[majorMinor] = constName
			k8sConstants = append(k8sConstants, Const{Name: constName, Version: majorMinor})
		}
	}

	// Map Kubernetes constants to CoreDNS constants
	for k8sVersion, coreDNSVersion := range versionMap {
		majorMinor := semver.MajorMinor(k8sVersion)
		versionMapList = append(versionMapList, versionMapEntry{
			KubernetesVersion: majorMinor,
			KubernetesConst:   k8sConstMap[majorMinor],
			CoreDNSConst:      coreDNSConstMap[coreDNSVersion],
		})
	}

	// Sort constants
	sort.Slice(k8sConstants, func(i, j int) bool {
		return semver.Compare(k8sConstants[i].Version, k8sConstants[j].Version) < 0
	})

	sort.Slice(coreDNSConstants, func(i, j int) bool {
		return semver.Compare(coreDNSConstants[i].Version, coreDNSConstants[j].Version) < 0
	})

	// Sort version map
	sort.Slice(versionMapList, func(i, j int) bool {
		return semver.Compare(versionMapList[i].KubernetesVersion, versionMapList[j].KubernetesVersion) < 0
	})

	data := map[string]interface{}{
		"KubernetesConstants": k8sConstants,
		"CoreDNSConstants":    coreDNSConstants,
		"VersionMap":          versionMapList,
	}

	return data
}

func versionToConst(prefix, version string) string {
	// Remove 'v' prefix if present
	versionNoV := strings.TrimPrefix(version, "v")
	// Replace dots with underscores
	versionNoV = strings.ReplaceAll(versionNoV, ".", "_")
	// Prepend the prefix and 'V'
	return prefix + "_V" + versionNoV
}
